[{"title":"A+B","path":"/article/A+B/","content":"思路设$f1=A,f_2=B,f_n(n2)=f{n-1}+f_{n-2},$则$f_3$就是ANSWER $A+B$。 推导设 $q^n=q^{n-1}+q^{n-2},$ 解得$(q≠0)q_1=\\frac{1+\\sqrt{5}}{2},q_2=\\frac{1-\\sqrt{5}}{2}$。\\再设$\\begin{cases} f_n=aq_1^{n-1}+bq_2^{n-1} \\ f_1=A,f_2=B\\end{cases}$\\代入，即得$\\begin{cases} a+b=A \\ a(\\frac{1+\\sqrt{5}}{2})+b(\\frac{1-\\sqrt{5}}{2})=B\\end{cases}$\\解二元一次方程组得$\\begin{cases} a=\\frac{B-A(\\frac{1-\\sqrt{5}}{2})}{\\sqrt{5}} \\ b=\\frac{A(\\frac{1+\\sqrt{5}}{2})-B}{\\sqrt{5}}\\end{cases}$\\再代入得$f_n=\\frac{1}{\\sqrt{5}}((B-A(\\frac{1-\\sqrt{5}}{2}))(\\frac{1+\\sqrt{5}}{2})^{n-1}+(A(\\frac{1+\\sqrt{5}}{2})-B)(\\frac{1-\\sqrt{5}}{2})^{n-1})$ 解答将 $n=3$ 代入 $f_n=\\frac{1}{\\sqrt{5}}((B-A(\\frac{1-\\sqrt{5}}{2}))(\\frac{1+\\sqrt{5}}{2})^{n-1}+(A(\\frac{1+\\sqrt{5}}{2})-B)(\\frac{1-\\sqrt{5}}{2})^{n-1})$\\得$\\begin{aligned}A+B = f_3\\ = \\frac{1}{\\sqrt{5}}((B-A(\\frac{1-\\sqrt{5}}{2}))(\\frac{1+\\sqrt{5}}{2})^{2}+(A(\\frac{1+\\sqrt{5}}{2})-B)(\\frac{1-\\sqrt{5}}{2})^{2})\\ = \\frac{1}{\\sqrt{5}}((B-A(\\frac{1-\\sqrt{5}}{2}))(\\frac{3+\\sqrt{5}}{2})+(A(\\frac{1+\\sqrt{5}}{2})-B)(\\frac{3-\\sqrt{5}}{2}))\\end{aligned}$ 实现只要计算$\\frac{1}{\\sqrt{5}}((B-A(\\frac{1-\\sqrt{5}}{2}))(\\frac{3+\\sqrt{5}}{2})+(A(\\frac{1+\\sqrt{5}}{2})-B)(\\frac{3-\\sqrt{5}}{2}))$,就可以得到 P1001 的AC。 代码#includebits/stdc++.husing namespace std;int main()\tdouble a,b,c=sqrt(5);\tcinab;\tprintf(%.0lf,((b-a*(1.0-c)/2.0)*(3.0+c)/2.0+((a*(1.0+c)/2.0-b)*(3.0-c)/2))/c);"},{"title":"P7012 [CERC2013] Draughts","path":"/article/sol-P7012/","content":"Description题目传送门：P7012 [CERC2013] Draughts。 简单回溯题目，你操作白棋，判断白棋最多能吃几个敌方的棋。 Analysis考虑 $n\\le10$，直接爆搜（回溯）。 分类讨论： 字符 $\\tt #$ 和 $\\tt .$ 表示空的黑色和白色方块，$\\tt W$ 表示有浅色棋子的方块，$\\tt B$ 表示有深色棋子的方块。 增量数组： const int dx[4] = -2,-2,2,2;const int dy[4] = -2,2,2,-2; 多组测试数据记得复原。 记得回溯。 找到每一个浅色棋子，去看它旁边有没有深色棋子。 记得找最大值，没有白棋输出 $-1$。 时间复杂度 $\\mathcal{O}(n^2)$。","tags":["题解"],"categories":["洛谷题解"]},{"title":"P10692 [SNCPC2024] 表达式矩阵","path":"/article/sol-P10692/","content":"Description题目传送门：P10692 [SNCPC2024] 表达式矩阵。 构造一个 $n \\times m$ 的矩阵，其中每个位置要么是 $1$，要么是 $\\tt +$ 或者 $\\tt ∗$，使得在满足每一行每一列均为一个合法表达式的前提下，最小化每一行、每一列表达式的值之和。 Analysis（转自官方题解） 对于行列大小均为偶数的情况，以 $6\\times 8$ 为例答案形如: 注意到每行 $/$ 每列恰有一个 $11$。由于无法构造出只含 $1$ 的解，显然使用乘号连接 $11$ 和 $1$ 是最优的。 对于列大小为奇数的情况，以 $6 × 9$ 为例如： 所有包含两个 $11$ 的行都必须使用一个 $+$，否则会产生 $11 \\times 11$ 的结果，这是我们不能接受的。 同时，除此之外每多使用一个 $+$，都会使答案增加，所以只需要在这些行中选恰好一个运算符改为 $+$ 即可。 行大小为奇数的情况类似。 对于行列大小均为奇数的情况，以 $7 × 9$ 为例： 所有包含两个 $11$ 的行都必须使用一个 $+$，所有包含两个 $11$ 的列都必须使用一个 $+$。 如图所示，观察位于交点的六个运算符，需要保证每行都有一个 $+$，每列都有一个 $+$。可以考虑斜着分配。 通过搜索和合理的剪枝，能在可接受的时间内算出答案。 考虑答案空间只有 $9 × 9$，可以搜出所有的答案硬编写在代码中。","tags":["题解"],"categories":["洛谷题解"]},{"title":"✨五分钟从零搭建自己的图床","path":"/article/PicX/","content":"前言在洛谷，拥有洛谷图床。但是，洛谷图床有些时候对用户名颜色、文件大小等有要求。于是，小编今天教你不用代码，五分钟搭建一个属于自己的个人图床。 PicX?️ PicX 是一款基于 GitHub API 开发的图床工具，提供图片上传托管、生成图片链接和常用图片工具箱服务。 ? 建议将本站添加到浏览器收藏夹，方便下次使用。 快捷键：Ctrl + D ? 作者：@XPoet ? 仓库：https://github.com/XPoet/picx ? 文档：https://picx-docs.xpoet.cn 前置要求 拥有一个 Github 账号，没有可以注册。 新建存储库 打开个人存储库，点击 $\\tt{\\color{green} New}$，转到新建页面。 创建一个新项目，如下图所示： 初始化 PicX 使用 OAuth。 打开官网https://picx.xpoet.cn/#/，单击使用 GitHub OAuth 授权登录。 按照 Github 给出的指示一步一步下去。 进入图床配置 填写用户名，项目名称，目录等，就好了。 使用 Token。 打开官网https://picx.xpoet.cn/#/，单击填写 GitHub Token 登录。 打开 Github 新建 Token，见视频。 ⚠️Token 只会在创建后出现一次，刷新就没了，请自己截图保存。 将 Token 输入即可绑定。 上传图片 按照平时使用洛谷图床的步骤使用即可。 点击 复制链接 即可获取图片链接。 自定义域名（可选）有些人不喜欢 GithubUserName.github.io 这个域名，那么就自己买一个域名用来绑定图床，比如 cdn.luogu.com.cn。 将网站部署至 Vercel 打开 Vercel，登录账号，没有可以注册。 点击 $\\tt{Add New}$ $\\dots$，选择 Project。 找到 Import Git Repository，将图床的 Github 项目名找到，点击 Import，找不到可以搜索。 按照指南一步一步下去，最后完成会出现烟花界面。 绑定域名 打开自己的域名运营商，找到域名解析控制台。 添加 CHEAM 类型的域名解析，值为 cname.vercel-dns.com（在项目已经部署至 Vercel 的情况下）。 打开 Vercel，找到项目，点击 Settings，找到 domain，在里面输入域名。 最后稍等一会，域名绑定成功。 更改路径 打开 https://picx.xpoet.cn/#/，右侧找到设置，下拉找到图片链接规则配置。 将 GitHub Pages 的链接规则改为 https://自定义域名/path，出现警告，不用管它。 将数据同步到云端仓库。 完成配置，可以自己测试，剩下功能自己探索。 注意事项 请勿使用 PicX 上传违反你当地法律的图片，所造成的一切后果与作者无关。 每次更改设置后或上传图片后，要更新至云端。 Github Token 只会在创建后出现一次，刷新就没了，请自己截图保存。 有时更新失败，可能是 Github 被墙了，请稍后在尝试。","tags":["PicX","洛谷","Github","图床","教程","视频教程"],"categories":["科技·工程"]},{"title":"P10676 『STA - R6』b20","path":"/article/sol-P10676/","content":"Description题目传送门：P10676 『STA - R6』b20。 简单模拟题。 Analysis给定一个字符串（网站名称）和一个整数（粉丝数），输出网站名称的第一位，和这个整数。 方便起见都做成 $\\operatorname{string}$，输出 $s_0\\ ^{[1]}$ 和 $s1\\ ^{[2]}$ 即可。 $^{[1]}$ 指网站名称的第一位，下表从 $0$ 开始。 $^{[2]}$ 指粉丝数，方便做成字符串。 注意输出不用带空格。 Code#include bits/stdc++.husing namespace std;int main()\tstring s; //网站名称\tstring s1;//粉丝数量 cin s s1;\tcout s[0] s1;\treturn 0;","tags":["题解"],"categories":["洛谷题解"]},{"title":"P10415 [蓝桥杯 2023 国 A] 切割","path":"/article/sol-P10415/","content":"Description题目传送门：P10415 [蓝桥杯 2023 国 A] 切割【暂无数据】。 简单数学题。 Analysis 求出 $W$ 和 $H\\ge2$ 的最小公因数。记为 $LCF$。 将 $LCF$ 依次去除 $W,H$。记为 $Lw,Lh$。 答案为 $Lw\\times Lh$。 计算公式： ANS=\\frac{W\\times H}{\\operatorname{LCF^2}}Code模拟即可。","tags":["题解"],"categories":["洛谷题解"]},{"title":"CF382B Number Busters","path":"/article/sol-CF382B/","content":"Description题目传送门：CF382B Number Busters。 Analysis 两个人玩游戏，他们有 $a$，$b$，$w$，$x$，$c$ 五个数，每秒可执行一次操作，要使最终结果为 $c\\le a$。操作如下：如果 $b\\ge x$，则 $b=b-x$，同时 $c=c-1$；如果 $bx$，则 $a=a-1$，$c=c-1$，$b=w-(x-b)$。求 $c\\le a$ 时已经走过的秒数。 题目已经说的很清楚了，按照模拟即可。 在 $ca$ 时，执行以下操作： $b \\ge x$ 时，$b=b−1$，$c=c−1$。 $b x$ 时，$a=a−1$，$c=c − 1$，$b=w−x+b$。 Code#include bits/stdc++.husing namespace std;int main()\ttypedef long long LL; LL a , b , w , x , c;\tcin a b w x c; //5个数字 LL ans = 0; //最后的秒数 while(c a) //模拟 if(b = x) b -= x , c --; else if(b x) a -- , c -- , b = w - (x - b); ans ++; //秒数++ cout ans endl;\treturn 0;","tags":["题解"],"categories":["洛谷题解"]},{"title":"P10313 [SHUPC 2024] 占地斗士！","path":"/article/sol-P10313/","content":"Description题目传送门：P10313 [SHUPC 2024] 占地斗士！。 简单搜索题。 Analysis容易发现，$1\\le n,m\\le10$，地图很小，所以考虑 DFS 算法。 其实是回溯，不是深度优先搜索。 题目不难，但细节多。 用变量存下已经放置的卡牌数量。 用 $\\mathcal{vis}$ 记录此卡牌是否放置过（不能直接改地图，这是回溯的重要部分）。 其它就是回溯+剪枝即可。 一些细节： 暴力枚举每个形状可以放的所有位置。 是 # 不能放，换个位置。 可以放的话，卡牌数自增，答案加上占地格子数，不是 $1$。 可以放，记得 $vis$ 标记位置。 若所有的卡牌都可以放入，那么直接输出 $18$，不用搜了，搜了小心 $\\tt TLE$，程序卡死。 都可以放入的数据如下： 输入10 10. . . . . . . . . .. . . . . . . . . .. . . . . . . . . .. . . . . . . . . .. . . . . . . . . .. . . . . . . . . .. . . . . . . . . .. . . . . . . . . .. . . . . . . . . .. . . . . . . . . . 输出18 代码模拟即可。","tags":["题解"],"categories":["洛谷题解"]},{"title":"「EPXLQ 2024」银辉描淡的石桥","path":"/article/「EPXLQ 2024」/","content":"Description题目传送门：「EPXLQ 2024」银辉描淡的石桥。 排序后计算 $\\text{rank}$ 后输出即可。在此之前，可以先完成此题。 Analysis 先来解决输出 Hahahai! 的问题。 定义变量 $flag$，先设置为都相同（true），在定义 $front$ 变量取头数据。后面输入时比较，如果发现不同的数据后，设 $flag$ 为 false。 判断部分代码如下：if(a[i].score != front)\tflag = false; 再来解决排序的问题。 先定义结构体，有两个参数：编号和成绩。接下来输入边输边存编号 a[i].number = i，后面写好自定义排序，定义映射类型（主打一个方便）的变量存 $\\text{rank}$ 后输出即可。 存 $\\text{rank}$ 的代码如下：for(int i = 1 ; i = n ; i ++)\tRank[a[i].number] = i;解释一下就是 $Rank[$ 这个人的学号 $]=$ 这个人的名次（$a$ 已经从大到小排过序）。 Code#include bits/stdc++.husing namespace std;struct node\tint score;\tint number;a[100001];map int , int Rank;bool flag = true;bool cmp(node x , node y)\treturn x.score y.score;int main()\tint n;\tcin n; cin a[1].score;\ta[1].number = 1;\tint front = a[1].score; for(int i = 2 ; i = n ; i ++) cin a[i].score; a[i].number = i; if(a[i].score != front) flag = false; if(flag) cout Hahahai!; return 0; sort(a + 1 , a + n + 1 , cmp); for(int i = 1 ; i = n ; i ++) Rank[a[i].number] = i; for(map int , int :: iterator it = Rank.begin() ; it != Rank.end() ; it ++) cout it-second ; return 0;","tags":["题解"],"categories":["个人记录"]},{"title":"P10401 「XSOI-R1」区间操作","path":"/article/sol-P10401/","content":"由于 Hexo 无法转义，详见原文：https://www.luogu.com.cn/article/2ifgwc5e。","tags":["题解"],"categories":["洛谷题解"]},{"title":"P10462 Number Base Conversion","path":"/article/sol-P10462/","content":"Description题目传送门：P10462 Number Base Conversion。 直接套板子。 Analysis模拟，记得开 long long。 $\\mathbb{n}$ 进制转十进制：套 c 语言库函数 strtol，该函数原型为 long int strtol(const char *str, char **endptr, int base)。其作用是将 $\\mathcal str$ 转换成 $10$ 进制。 十进制转 $\\mathbb{n}$ 进制：短除法，用基数 $n$ 去除，直到商为 $0$，逆序输出。 以 $114514$ 转 $16$ 进制举例： 16{\\big|}\\kern{3px}114514\\kern{-35px}\\raisebox{-2px}{\\underline{\\kern{40px}}}\\\\ \\kern{32px}16{\\big|}\\kern{7px}7157\\kern{-28px}\\raisebox{-2px}{\\underline{\\kern{35px}}}\\kern{5px}\\cdots\\kern{5px}2\\\\ \\kern{36px}16{\\big|}\\kern{7px}447\\kern{-23px}\\raisebox{-2px}{\\underline{\\kern{31px}}}\\kern{6px}\\cdots\\kern{5px}5\\\\ \\kern{60px}16{\\big|}\\kern{7px}27\\kern{-19px}\\raisebox{-2px}{\\underline{\\kern{27px}}}\\kern{6px}\\cdots\\kern{5px}15(\\text F)\\\\ \\kern{84px}1\\kern{15px}\\cdots\\kern{5px}11(\\text B)\\\\ (114514)_{10} = (BF52)_{16}#define int long longstring zhuanhuan(int number , int n)\tstring ans; while(number) if(number % n = 10) ans += char(number % n + A - 10); else ans += char(number % n + 0); number /= n; reverse(ans.begin() , ans.end());\treturn ans; Code拼接上面代码+根据题目模拟即可。","tags":["题解"],"categories":["洛谷题解"]},{"title":"P10522 [XJTUPC2024] 雪中楼","path":"/article/sol-P10522/","content":"Description题目传送门：P10522 [XJTUPC2024] 雪中楼。 由于 $n \\le 2 \\times 10^5$，插入次数太多，考虑维护链表。 Analysis对于每次操作，输入 $a_i$，若 $i=0$ 就将 $a_i$ 插到链表尾部，否则插到 $a_i$ 左边，最后翻转完输出，就这么简单。 Code#include bits/stdc++.husing namespace std;#define MAXN 2e5 + 10list int l;list int :: iterator number[int(MAXN)] = l.begin() , l.end();main()\tint n;\tcin n; for(int i = 1 ; i = n ; i ++) int x; cin x; number[i] = l.insert(number[x] , i); //插入函数 reverse(l.begin() , l.end()); //翻转 for(list int :: iterator it = l.begin() ; it != l.end() ; it ++) // 迭代器 cout *it ; return 0;","tags":["题解"],"categories":["洛谷题解"]},{"title":"P10520 [XJTUPC2024] 榕树之心","path":"/article/sol-P10520/","content":"Description题目传送门：P10520 [XJTUPC2024] 榕树之心。 求： x^{\\prime} = \\frac{1}{2} x + \\frac{1}{2} yy^{\\prime} = \\frac{\\sqrt{3}}{2} x - \\frac{\\sqrt{3}}{2} yAnalysis直接模拟即可（运算记得带小数）。| 式子 | 作用 || :—————: | :—————: || $\\frac{1}{2}x$ | $x \\div 2.0\\ \\operatorname{or} \\ 0.5 \\times x$ || $\\sqrt{x}$ | $\\operatorname{sqrt}(x \\times 1.0)$ | Code#include bits/stdc++.husing namespace std;int main()\tint x , y;\tcin x y; cout fixed setprecision(6) ((1/2.0)*x) + ((1/2.0) * y) fixed setprecision(6) ((sqrt(3.0) / 2.0) * x) - ((sqrt(3.0) / 2.0) * y);\treturn 0;","tags":["题解"],"categories":["洛谷题解"]},{"title":"P10532 [XJTUPC2024] 筛法","path":"/article/sol-P10532/","content":"Description题目传送门：P10532 [XJTUPC2024] 筛法 求： \\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^n\\lfloor \\dfrac{n}{\\max(i,j)}\\rfloor [i \\perp j]显然发现答案为 $n^2$。 Analysis（转自讲评视频）我们可以从几何的角度出发: 考虑二维平面的 $n^2$ 个点 $(i,j)\\ 1\\le i,j\\le n$。 从原点向每个满足 $i\\perp j$ 的点 $(i,j)$ 引出一条射线，可以发现这 $n^2$ 个点均唯一存在于其中一条射线上，应为当 $\\gcd(i,j) ot=1$ 时，$(i,j)$ 会被 $(\\frac{i}{\\gcd{(i,j)}},\\frac{j}{\\gcd{(i,j)}})$ 引出的射线覆盖。 我们再对每个 $i\\perp j$ 的点对 $(i,j)$ 考虑其引出射线覆盖的点数，不难发现恰好就是 $\\frac{n}{\\max{(i,j)}}$，因为对所有 $1\\le k\\le \\frac{n}{\\max{(i,j)}}$，点对 $(ik,jk)$ 在这条射线上，当 $k$ 再大时 $ik,jk$ 中至少有一维超过 $n$。 故 \\sum_{i=1}^{n}\\sum_{j=1}^{n}[i\\perp j][\\frac{n}{\\max{(i,j)}}]可以理解为对所有互质的 $(i,j)$ 求上述射线所覆盖的点对数量，在上述结论中可知该和为 ${n}^{2}$。 还有几种解法不说了，可以自行去看讲评回放。 Codex = int(input())print(x * x)","tags":["题解"],"categories":["洛谷题解"]},{"title":"P10264 [GESP202403 八级] 接竹竿","path":"/article/sol-P10264/","content":"Description题目传送门：P10264 [GESP202403 八级] 接竹竿 思维题，考虑倍增。 Analysis $30pts$ 模拟，$1\\le a_i\\le13$，根据题意，队列中不会存在两个相同的点数，所以队列的最大长度为 $13$，对于每一个 $(l,r)$，模拟加队列的过程，每添加一个牌从队列头开始查找有无相同的点数，如有则从队列中删除所有后续的元素。复杂度为 $O(T\\times q\\times N\\times13)$。 $100pts$ 倍增，一共 $13$ 个点数，由题意，从自身出发，到下一个相同点数，这样的整段都可以被取走。每个点都可以维护下一个相同点数的位置。\\但是这样的跳跃速度还是太慢了，通过倍增来加速。$nxt[i][j]$ 表示从 $i$ 出发的，第 $2\\land j$ 个段的结尾位置。可知 $nxt[i][j+1]=nxt[nxt[i][j]+1][j]$。\\复杂度 $O(T\\times q\\times \\log N)$。 Code//Reprinted from gesp.ccf.org#includebits/stdc++.husing namespace std;#define ll long longconst int N = 1e5 + 10;int a[N];int nxt[N][30], pos[20];int main() int t;\tcin t;\twhile (t--) int n; cin n; memset(pos, 0, sizeof pos); for (int i = 1; i = n; i++) cin a[i]; for (int j = 0; j = 20; j++)nxt[i][j] = n + 1; for (int i = n; i = 1; i--) if (!pos[a[i]]) nxt[a[i]][0] = n + 1; pos[a[i]] = i; else nxt[i][0] = pos[a[i]]; pos[a[i]] = i; for (int i = n; i = 1; i--) for (int j = 1; j = 20; j++) if (nxt[i][j - 1] + 1 = n) nxt[i][j] = nxt[nxt[i][j - 1] + 1][j - 1]; int q; cin q; while (q--) int l, r; cin l r; int ii = l; int ans = 0; while (ii = r) while (ii = r nxt[ii][0] r) ii++; ans++; if (ii r)break; for (int j = 20; j = 0; j--) if (nxt[ii][j] = r) ii = nxt[ii][j]; break; ii++; cout ans ;","tags":["题解"],"categories":["洛谷题解"]},{"title":"✨简简单单写程序","path":"/article/Hello-Word/","content":"每个伟大的梦想，都有一个微不足道的开始。 程序的设计目标和流程设计一个程序是为了让计算机始终不渝地遵循指令，以完成特定的任务。为了能让计算机听懂指令，我们编写程序来与计算机交流。 编程方法 使用IDE（集成编辑环境）例如：Dev C++ / CodeBlocks。 使用洛谷在线编程 https://www.luogu.com.cn/ide。 什么是编程程序 就是为实现特定目标或解决特定问题而用计算机语言编写的一系列令序列。 计算机语言 是人与计算机之间通信的语言。 编程 是程序员为解决特定问题，按照自己的思路，在遵循特定的计算机语言规则下编写程序的过程。 C++ 语言以 C++ 语言规则为例来学习编程。 直接原因： 信息学竞赛只允许使用 C++。 其他原因： 比较底层，运行速度快。 C++ 是编译语言，需要编译成可执行文件。 例1. 你好洛谷编写一个程序，让计算机告诉大家我爱洛谷，即I love Luogu! 代码如下： 输入输出自行百度。 解决算法问题的步骤 变量用于存放数据的容器。 有不同的类型——整数、浮点数、字符，等等。变量的值可以变化。 可以当做表达式的一部分参与计算。 定义#include bits/stdc++.husing namespace std;int main()\t数据类型 变量名;\treturn 0; 常见类型 类型名 作用 int 整型，如 int a = 1; float double 浮点，一个单精度，一个双精度。如 double a = 3.1415926 bool 布尔，只有 0 或 1，代表真和。如 bool flag = 0; //或者 bool flag = false; char 字符型，内存放字符，定义或访问时要用单引号包着，如 char a = A; 变量的名称 只能由英文字母、数字和下划线（_） 组成。 不能以数字开头。 不能和其他“关键字”重复。关键字（又称保留字）有很多，比如 if , int。 要区分大小写，如 $Ans$ 和 $anS$ 是两个完全不同的变量。 数学C++ 还可以运算数学，（常用的）具体如下：| 数学符号 | C++ 运算符号 || :—————: | :—————: || $+$ | $+$ || $-$ | $-$ || $\\times$ | $*$ || $\\div$ | $/$ | 还有一些二进制运算符后面会学到。 实例：#include bits/stdc++.husing namespace std;int main()\tcout 114 * 514 / 114514 + 114514 endl;\treturn 0; 一些注意的点 不能除 0。 浮点运算必须带有至少一个浮点数，不然默认整型，会产生精度误差。 学以致用超级玛丽游戏 超级玛丽是一个非常经典的游戏。请你用字符画的形式输出超级玛丽中的一个场景。 ******** ************ ####....#. #..###.....##.... ###.......###### ### ### ........... #...# #...# ##*####### #.#.# #.#.# ####*******###### #.#.# #.#.# ...#***.****.*###.... #...# #...# ....**********##..... ### ### ....**** *****.... #### #### ###### #####################################################################...#......#.##...#......#.##...#......#.##------------------############################################------------------##..#....#....##..#....#....##..#....#....############################################################### #----------##.....#......##.....#......##.....#......# #----------########################################### #----------##.#..#....#..##.#..#....#..##.#..#....#..# #----------########################################### ############ 分析多行输出即可，注意加上换行 endl 或 。#includebits/stdc++.husing namespace std; int main()\tcout ******** ;\tcout ************ ;\tcout ####....#. ;\tcout #..###.....##.... ;\tcout ###.......###### ### ### ;\tcout ........... #...# #...# ;\tcout ##*####### #.#.# #.#.# ;\tcout ####*******###### #.#.# #.#.# ;\tcout ...#***.****.*###.... #...# #...# ;\tcout ....**********##..... ### ### ;\tcout ....**** *****.... ;\tcout #### #### ;\tcout ###### ###### ;\tcout############################################################## ;\tcout#...#......#.##...#......#.##...#......#.##------------------# ;\tcout###########################################------------------# ;\tcout#..#....#....##..#....#....##..#....#....##################### ;\tcout########################################## #----------# ;\tcout#.....#......##.....#......##.....#......# #----------# ;\tcout########################################## #----------# ;\tcout#.#..#....#..##.#..#....#..##.#..#....#..# #----------# ;\tcout########################################## ############ ;\treturn 0; 另外一些事情 推荐算法平台：洛谷。 洛谷创办于2013年,致力于为参加noip、noi、acm的选手提供清爽、快捷的编程体验。它拥有在线测题系统、强大的社区、在线学习功能。很多教程内容由各位oiers提供的,内容广泛。 Debug 先可以尝试模拟代码，找到错误；实在不行可以在洛谷发帖求助。 推荐的书 覆盖算法竞赛语言、基础算法，打好坚实基础 本书从介绍 C++ 语言开始，各个击破程序设计竞赛中的基础考点，包括各种基础算法、数据结构和数学知识。 这些都是重中之重，如果没有掌握这些知识，继续深入的学习就如同试图建设空中楼阁。这些知识对读者的数学水平要求不高，有初中的数学基础即可阅读。 深入浅出，解答“是什么、为什么、怎么办”的问题 正如本书的书名一样，本书力求使用浅显易懂的语言讲述各种深刻的算法思想，因此读起来生动有趣，而不是面对冰冷的数学符号和代码。 每个专题中都会以精心选择的例题为主线，先介绍这个知识点是用来干什么的；然后花费大量的篇幅，图文并茂地介绍各个知识点的详细过程和代码实现方法；最后结合题目，介绍了如何将算法应用到实战中。有些例题甚至介绍了多种不同做法，帮助读者拓展思维，举一反三。 适用人群：备战 NOIP、ICPC 等算法竞赛的初阶选手 本书的多数例题都配备代码风格良好的示例代码，可以帮助读者更好地学习算法如何使用代码实现。在讲解的过程中给出了大量的算法竞赛中需要注意的琐碎问题，这些都是前人的经验之谈，希望读者可以少走弯路。 近 400 道例题和习题，可以在线提交评测。 本书有约 400 道例题和习题。为了节约阅读时间和篇幅，例题和习题都只保留了题意简述。大部分的题目都可以在洛谷中找到并提交代码评测，还可在洛谷阅读其他同学提供的题解并进行讨论。 题目选材范围多样，覆盖了应当学习了解的知识点。如果读者能够完全掌握这些题目，相信可以有相当程度的进步。 可以先尝试适读，链接。 洛谷试炼场（用于练习熟练度）新手村任何一个伟大的目标，都有一个微不足道的开始。 洛谷入门勇敢的迈出第一步，了解下语言和洛谷。跟着书本和老师走，不会难的。 P1000 P1001 P1421 P1425 顺序与分支计算机的智能性开始得以体现，因为计算机能够根据不同的条件选择了。 P1422 P1085 P1089 P1909 循环！循环！循环！计算机最不怕的就是重复。你让它做10000次同样的事它也不怕啦，但是让他做1亿亿次的话…… P1008 P1035 P1423 P1424 P1980 数组跟数组有关的题目基本上都要用到循环，所以请先完成前面几部分。 P1046 P1047 P1427 P1428 P2141 P1567 简单字符串计算机不仅可以处理数字，还能处理文字！就是其实跟数字也没什么差。 P1055 P1200 P1308 P1553 P1598 P1914 过程函数与递归将代码串进行打包，就是过程与函数。过程与函数调用自己则为递归。有一点小难但不要怕哦。 P1028 P1036 P1149 P1217 BOSS战-入门综合练习1这里将前面的内容综合起来了，会有点难，不过你可以问老师同学，也能上网查资料。 P1478 P1618 P1579 P2089 BOSS战-入门综合练习2勇士，竟然来到了BOSS的老巢！来一场恶斗，证明自己的实力，解锁下一个级别！ P1426 P1464 P1014 P1022 P1307 普及练习场普及组选手可冲刺训练，提高组选手亦可在此巩固基础。 简单的模拟开始普及组的训练！所谓模拟，就是直接根据题意编写，思维难度简单。 P1003 P1067 P1540 P1056 P1328 P1563 交叉模拟这里也是模拟，但是会混有些别的部分。思维难度不大，但是编写起来会有些难度。 P1023 P1031 P1042 P1086 P1098 P3952 排序将杂乱无章的数据变得有规律。有各种各样的排序算法，看情况使用。 P1177 P1059 P1068 P1781 排序Ex这里的排序就更上一层了。不仅融合了别的算法与技巧，排序本身也有各种花招。 P1583 P1051 P1093 P1309 字符串处理这里的字符串处理还会变得更加的有意思，难度也更大。需要好好地思考一下。 P1603 P1071 P1012 P1538 贪心贪心就是只考虑眼前的利益。对于我们人生来说太贪是不好的，不过oi中，有时是对的。 P1090 P1181 P1208 P1223 P1094 P1803 P1031 P1080 深度优先搜索搜索可以穷举各种情况。很多题目都可以用搜索完成。就算不能，搜索也是骗分神器。 P1219 P1019 P1101 P1605 P1040 P1092 广度优先搜索广度优先搜索可以用来找有关“最短步数”的问题。嗯，也可以用来“地毯式搜索”。 P1162 P1032 P1141 P1126 P1443 带有技巧的搜索这里的搜索不仅包含了dfs和bfs，还包括剪枝、记录等技巧以加快速度。 P1118 P1434 P1433 P1074 分治算法将大问题拆分为小问题，分而治之，各个击破，然后在合并回来。 P1226 P1010 P1908 P1498 简单数学问题用计算机解决某些麻烦数学问题，再合适不过了。这真是绝妙的搭配啊！ P1088 P1045 P1403 P1017 P1147 P1029 递推与递归二分递推，层层递进，由基础推向顶层。二分不仅可以用来查找数据，还可以确定最合适的值。 P1192 P1025 P1057 P1135 P1216 P1182 P1316 线性数据结构数组，链表，队列，栈，都是线性结构。巧用这些结构可以做出不少方便的事情。 P1996 P1115 P1739 P1160 P1449 树形数据结构由一个根节点分叉，越分越多，就成了树。树可以表示数据之间的从属关系 P1087 P1030 P1305 P5018 背包问题这是最基础的动态规划。不过如果是第一次接触会有些难以理解。加油闯过这个坎。 P1060 P1164 P1064 P1048 P1049 P1616 线性动态规划这也是基础的动态规划。是在线性结构上面的动态规划，一定要掌握。 P1020 P1091 P1280 P1880 P1140 P1282 多维动态规划这里的动态规划就不止一维了。不仅要小心时间复杂度，也要注意空间复杂度。 P1508 P1006 P1387 P1417 P1855 P1736 动规与记忆化这边的题目有各种搞法。当然有的题目也可以使用记忆化搜索来降低思维难度。 P1064 P1541 P1026 P1063 P1156 P1052 高精度算法就算是long long（或int64）还不够怎么办？用高精度算法。自己动手丰衣足食。 P1601 P2142 P1303 P1255 P1604 贪心Pro虽然是贪心题，可能不是你当时你虐着玩的贪心惹qwq P1080 P1031 P1233 P2123 简单数论数学和OI是密切相关的，数学不仅是OI的基础，而且是算法的核心。 P1865 P1372 P1338 P2158 P1582 BOSS战-普及综合练习1好不容易闯到这一关，你那还等什么呢？抄起家伙赶快上啊！ P1478 P1203 P1363 P1736 BOSS战-普及综合练习2来搞定第二个BOSS。虽然战斗艰难，但你一定没有问题。 P1201 P1095 P1058 P2258 P1108 BOSS战-普及综合练习3普及练习场的大BOSS：“一定让你有去无回”。怎么办呢？只能打倒他开启下一个级别！ P1328 P1062 P1969 P1037 普及常见模板这里集中了比较基础的算法的模板。提高和省选也有模板题哦！ P1177 P3366 P3367 P3371 P3383 提高历练地已经去除普及组难度，请大家放心。成长大牛之必写题！！！ 搜索Ex开始提高组的试炼。这里已经去除了所有普及组难度的题目。哼哼，怕了吧？ P1120 P1378 P1514 P1312 P1441 P1242 动态规划LV_1这是提高组难度中比较基础的动态规划，也许一两个转移方程就可以写出。 P1005 P1373 P2279 P1220 P1156 动态规划LV_2这里的动态规划稍稍有所加大难度，思考转移方程的时间可能会与编写程序的时间持平。 P1273 P1169 P2577 P1070 P2051 动态规划LV_3比较需要技巧的动态规划。有的不仅仅需要状态转移方程，可能还会与别的算法综合。 P1415 P2157 P2216 P2331 P2467 P3084 数论数论就是研究整数的理论。包括公约公倍数、质数、欧拉定理和同余方程等。 P2152 P1414 P1134 P1313 P1306 博弈论博弈论考虑游戏中的个体的预测行为和实际行为，并研究它们的优化策略。 P1199 P1288 P1290 P2148 P1247 P2575 其他数学问题听说学OI的同志们数学都挺好。那么。就请完成下面的题目证明这一点吧！ P1357 P1641 P2059 P2154 P2261 P2327 P1066 图的遍历图是一种非常重要的数据结构，描述对象复杂的练习。这里开始接触图的基本概念。 P2661 P1330 P1341 P2921 最短路问题最短路是图论中最重要的部分，多种算法可以应用。很多题目都可以抽象成这种模型。 P1339 P1462 P1346 P1119 P1144 P1522 最小生成树最小生成树可以用kruskal（克鲁斯卡尔）算法或prim（普里姆）算法求出。 P1546 P2330 P1991 P1265 较复杂图论I别的些图论问题，包括树、拓扑排序等。要过这一关，需要学习不少新的算法。 P1113 P1268 P1525 P1983 较复杂图论II更高级的图论算法。包括差分约束、强连通、二分图等。会更难一些。 P1993 P1726 P2055 P2149 P1345 并查集用于处理一些不相交集合的合并及查询问题。常常在使用中以森林来表示。 P1111 P2024 P1197 P1196 堆堆总是一棵完全树；堆中某个节点的值总是不大于或不小于其父节点的值。 P1801 P2278 P1631 P2085 P1484 线段树树状数组基础这都是比较高级的线性数据结构。在处理一些询问与修改线性问题时，是很好用的。 P1972 P1198 P2023 P2161 神奇的解法有些问题刚开始觉得无从下手。好好想一想，尽量别看题解，否则你会大呼“简单”。 P1007 P1984 P2022 P2320 倍增一种特殊的枚举算法，但可大大加快效率。近年noip有考到。难度较大。 P1967 P1081 P1613 强连通分量 P2341 P3469 P2746 P3119 P3225 BOSS战-提高综合练习1年轻人，又是个送上门的，让我来看看你真实的本领。啊哈哈哈哈哈！ P2264 P1772 P1083 P1979 P2939 BOSS战-提高综合练习2再来！这里有的题目并非单纯的考察某个算法，而是考察一种综合性的思维。 P1901 P1314 P2144 P1073 P2324 BOSS战-提高综合练习3既然已经打倒了前面2个boss，那么第3个也是没有问题的。少年，来吧！ P1965 P1311 P2296 P1084 提高模板-O(nlogn)数据结构虽然这些算法不是NOIp必须的，但是不算困难，很多题目可以使用这些方法。 P3374 P3368 P3372 P3373 P1439 P3378 省选斗兽场/NOI神殿为省选及以上选手制作的训练场。其实，省选水平的oier不需要一些外加的刷题列表，本栏仅供参考，也欢迎各位指出不足。 省选基础-读入/输出优化读入/输出优化是省选刷题时必要的一个东西，这里给出了几题，需要自己手写相应的读入输出处理。作为第一关，这一关相对简单。 P1580 P2393 P2394 省选基础-位运算位运算往往在必要的时候,能带你优化一下常数,也许是空间;也许是时间;有的时候这样可以多过很多分 P2114 P2396 P2397 省选基础-打表打表虽然很赖皮,而且基本都是非正解,但是这种办法能让我们在省选中拿到一些会超时或者会超空间的一些数据点 P1149 P1463 P1896 动态规划1动态规划 P2051 P1879 P1850 P2831 P1131 P1169 动态规划2动态规划 P1273 P3648 P2519 P2515 P3233 P2501 网络流——最大流最大流 P2765 P2764 P2763 P2766 P2774 P2805 网络流——费用流费用流 P2153 P2053 P3159 P2604 P2050 P3980 单调队列单调队列 P2698 P2216 P2219 P2564 P2569 概率期望概率期望 P2473 P2221 P3317 P3343 P3600 P3830 二分图二分图 P3386 P1640 P1129 P1963 P3231 P2526 点分治点分治 P2634 P2664 P3806 P3676 后缀数组后缀数组 P3809 P1117 P2178 P2463 P2336 主席树主席树 P2468 P3157 P3302 P3168 P3313 数位DP数位DP P2602 P3281 P2518 P2606 AC自动机AC自动机 P3808 P3796 P2444 P2414 平衡树平衡树 P2042 P2596 P1110 P3285 P3644 P3765 P3369 树链剖分树链剖分 P2590 P2486 P2146 P3258 P3178 动态树动态树 P3690 P2387 P3203 P3348 树套树树套树 P1903 P3157 P3332 P2166 P3380 P2137 P3759 可持久化Trie树可持久化Trie树 P2048 P3527 P3302 P3168 P3242 P3241 P3293 莫队算法莫队算法 P1972 P2336 P3709 P2709 P3674 分块分块 P1972 P3396 P1822 P2801 P3203 莫比乌斯反演莫比乌斯反演 P3768 P3172 P3455 P2522 P3327 其他其他 P3377 P3261 P3382 P2571 P3222 P3187 P3199 P3292 P2824 P3285 P1552 USACO美国经典的算法练习题库，值得一刷 USACO Section 1.1 P1200 P1201 P1202 P1203 USACO Section 1.2完全枚举 P3864 P1204 P1205 P1206 P1207 USACO Section 1.3贪心 P1208 P1209 P1211 P1444 P3650 P2693 USACO Section 1.4有技巧的枚举 P1214 P1215 USACO Section 1.5二进制数 P1216 P1217 P1218 USACO Section 2.1图论和洪水填充 P1457 P1458 P1459 P1460 P1461 USACO Section 2.2数据结构与动态规划 P1465 P1466 P1467 P1468 USACO Section 2.3 P1470 P1472 P1473 P1474 P1475 USACO Section 2.4最短路径 P1518 P1519 P1522 P1529 P1530 USACO Section 3.1最小生成树 P1546 P2722 P2723 P2724 P2725 USACO Section 3.2背包问题 P1134 P2727 P2728 P2729 P2730 P1828 USACO Section 3.3欧拉回路 P2731 P2732 P1930 P2733 P2734 USACO Section 3.4计算几何 P1827 P2735 P2736 USACO Section 4.1最优化 P2737 P2738 USACO Section 4.2网络流 P2740 P1894 P2751 USACO Section 4.3高精度 P2687 P2752 P2753 USACO Section 4.4 P1344 P2739 P2741 USACO Section 5.1二维凸包 P2742 P2743 P2749 USACO Section 5.2 P1560 USACO Section 5.3启发式搜索 P2701 P2744 P2745 P2746 USACO Section 5.4 P1345 P2747 P2748 USACO Section 5.5 P1709 P1856 P2750","tags":["洛谷,教程"],"categories":["算法·理论"]},{"title":"P10314 [SHUPC 2024] 函数","path":"/article/sol-P10314/","content":"题目传送门：P10314 [SHUPC 2024] 函数 解函数题。 函数解读f(x)=x-0.5+\\frac{\\arctan(\\cot(\\pi x))}{\\pi} 函数 名称 $\\operatorname{c++}$ $\\arctan$ 反正切函数 $\\operatorname{atan}(\\operatorname{double} x)$ $\\cot$ 余切函数 $1.0/\\tan(\\operatorname{double} x)$ $\\pi$ 圆周率 std::numbers::pi 所以，我们可以得出代码： inline double f(double x)return x - 0.5 + atan(1.0 / tan(std::numbers::pi * x)) / std::numbers::pi;CODE#include bits/stdc++.husing namespace std;inline double f(double x)return x - 0.5 + atan(1.0 / tan(std::numbers::pi * x)) / std::numbers::pi;int main()\tint T;\tcin T; while(T --) double x; cin x; printf(%7f , f(x)); return 0; QA Q：为什么过不了编译？ A：因为有 std::numbers::pi，所以要用 c++20 提交。 Q：为什么 $\\cot(x) = \\frac{1}{\\tan x}$？ A：按照三角函数，$\\cot x = \\frac{b}{a}$ , $\\tan x = \\frac{a}{b}$，即 $\\cot$ 和 $\\tan$ 互为倒数，所以$\\cot(x) = \\frac{1}{\\tan x}$。有问题欢迎评论区留言~","tags":["题解"],"categories":["洛谷题解"]},{"path":"/about/index.html","content":"Hey, Look here! 👋 I’m heikeshaonain, a office worker from Ningbo, China. I ❤️ code because I am a coder. ⚒️ CSS/HTML/JavaScript/Vue/Typescript/React/PHP 📦 Building ✏️ VS Code / Notepad++ / Navicat 🌱 Prepare to study advanced web front end development 👨 Pronouns: he/him 🤔 Constantly make yourself better 📊 Weekly development breakdown Vue 2 hrs 37 mins █████████▒░░░░░░░░░░░░░░░ 37.76 % React 2 hrs 4 mins ███████▒░░░░░░░░░░░░░░░░░ 29.88 % Markdown 42 mins ██▓░░░░░░░░░░░░░░░░░░░░░░ 10.26 % Javascript 32 mins ██░░░░░░░░░░░░░░░░░░░░░░░ 07.82 % css 26 mins █▓░░░░░░░░░░░░░░░░░░░░░░░ 06.44 %"}]